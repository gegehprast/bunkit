import { err, ok, type Result } from "@bunkit/result"
import type { RouteRegistry } from "./route-registry"

/**
 * Options for generating route types
 */
export interface GenerateRouteTypesOptions {
  /** Only generate for specific routes (optional) */
  routes?: string[]
}

/**
 * Options for exporting route types
 */
export interface ExportRouteTypesOptions extends GenerateRouteTypesOptions {
  /** Output file path */
  outputPath: string
}

/**
 * Extract parameter types from a route path
 * e.g., "/users/:id" -> { id: string }
 * e.g., "/posts/:postId/comments/:commentId" -> { postId: string, commentId: string }
 */
function extractParamsFromPath(path: string): Record<string, string> {
  const params: Record<string, string> = {}
  const segments = path.split("/").filter(Boolean)

  for (const segment of segments) {
    if (segment.startsWith(":")) {
      // Handle wildcard params (:path*)
      const paramName = segment.endsWith("*")
        ? segment.slice(1, -1)
        : segment.slice(1)
      params[paramName] = "string"
    }
  }

  return params
}

/**
 * Generate TypeScript type string for route parameters
 */
function generateParamType(params: Record<string, string>): string {
  const keys = Object.keys(params)

  if (keys.length === 0) {
    return "Record<string, never>"
  }

  const entries = keys.map((key) => `${key}: ${params[key]}`)
  return `{ ${entries.join("; ")} }`
}

/**
 * Generate TypeScript declaration for registered routes
 */
export function generateRouteTypes(
  registry: RouteRegistry,
  options: GenerateRouteTypesOptions = {},
): Result<string, Error> {
  try {
    const routes = registry.getAll()

    // Filter routes if specified
    const filteredRoutes =
      options.routes && options.routes.length > 0
        ? routes.filter((r) => options.routes?.includes(r.path))
        : routes

    // Group routes by path to avoid duplicates
    const routesByPath = new Map<string, Record<string, string>>()

    for (const route of filteredRoutes) {
      if (!routesByPath.has(route.path)) {
        const params = extractParamsFromPath(route.path)
        routesByPath.set(route.path, params)
      }
    }

    // Generate TypeScript declaration
    let output = "/**\n"
    output +=
      " * Auto-generated route types for type-safe internal redirects.\n"
    output += " * DO NOT EDIT THIS FILE MANUALLY - it will be regenerated.\n"
    output += " */\n\n"
    output += 'declare module "@bunkit/server" {\n'
    output += "  interface RegisteredRoutes {\n"

    // Sort routes for consistent output
    const sortedPaths = Array.from(routesByPath.keys()).sort()

    for (const path of sortedPaths) {
      // biome-ignore lint/style/noNonNullAssertion: We know this exists because we just set it above
      const params = routesByPath.get(path)!
      const paramType = generateParamType(params)
      output += `    "${path}": ${paramType}\n`
    }

    output += "  }\n"
    output += "}\n\n"
    output += "export {}\n"

    return ok(output)
  } catch (error) {
    return err(
      error instanceof Error
        ? error
        : new Error("Failed to generate route types"),
    )
  }
}

/**
 * Export route types to a file
 */
export async function exportRouteTypes(
  registry: RouteRegistry,
  options: ExportRouteTypesOptions,
): Promise<Result<void, Error>> {
  const typesResult = generateRouteTypes(registry, options)

  if (typesResult.isErr()) {
    return typesResult as Result<void, Error>
  }

  try {
    const file = Bun.file(options.outputPath)
    await Bun.write(file, typesResult.value)
    return ok(undefined)
  } catch (error) {
    return err(
      error instanceof Error
        ? error
        : new Error("Failed to export route types"),
    )
  }
}
